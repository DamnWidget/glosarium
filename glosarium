#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Copyright (c) 2013 Oscar Campos <oscar.campos@member.fsf.org>

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

"""
.. module:: glosarium
    :platform: POSIX, Windows
    :synopsis: This module locates in a text file the given glosary terms

.. moduleauthor:: Oscar Campos <oscar.campos@member.fsf.org>
"""

import os
import re
import sys
import httplib2
from optparse import OptionParser

__version__ = '1.0'


class WebParser(object):
    """
    This class is used to parse the Glosarium GNU web page and generates a
    list of terms to use in our glosary

    :param url: the URL to parse
    :type url: str
    """

    def __init__(self, url=None):
        if url is None:
            self.url = (
                'http://www.gnu.org/server/standards/translations/es/'
                'recursos.html#glosario'
            )
        self.glosary = []

        self._parse()

    def _parse(self):
        """I parse the web site
        """

        h = httplib2.Http('/tmp/.cache')
        resp, content = h.request(self.url)

        if resp.get('status') != '200':
            print 'error: the server at {0} reply {1} exiting...'.format(
                self.url,
                resp.get('status')
            )
            sys.exit(1)

        regex = re.compile(r'<strong>.*?</strong>')
        self.glosary = [term[8:-9] for term in regex.findall(content)]


def main():
    """Main application entry point
    """

    parser = OptionParser(usage=(
        'usage: %prog po_file <log_file>\nType %prog -h or --help to get help'
    ))
    parser.add_option(
        '-v', '--version', action='store_true', dest='version',
        help='show program\'s version number and exit'
    )
    parser.add_option(
        '-l', '--lines', action='store_true', dest='lines',
        help='also print lines when a term is found'
    )
    parser.add_option(
        '-r', '--resume', action='store_true', dest='resume',
        help='print a resume when done'
    )
    (options, args) = parser.parse_args()

    if options.version:
        sys.stdout.write('glosarium %s\n' % __version__)
        sys.exit(0)

    if not len(args):
        parser.error('You must provide the Po file that you want to check')

    if len(args) > 1:
        dest = os.path.abspath(args[1])
    else:
        dest = None

    source = os.path.abspath(args[0])
    glosary = WebParser().glosary

    with open(source, 'r') as fd:
        lines = fd.readlines()

    result = []
    if options.resume:
        resume = {}

    regex = re.compile(
        r'(href=\\?"\\?\b(https?|ftp|file|mailto):/?/?\S+"|src="\b\S+")'
    )

    for i in range(len(lines)):
        for term in glosary:

            if term.lower() in lines[i].lower():
                # skip matches on href urls or src
                m = regex.search(lines[i])
                if m is not None:
                    if term.lower() in m.group():
                        continue

                if options.resume and term not in resume:
                    resume[term] = []

                result.append(
                    'Term {term} found in line {line}'.format(
                        term=term, line=i + 1
                    )
                )
                if options.lines:
                    result.append('|__\n   ' + lines[i])

                if options.resume:
                    resume[term].append(i + 1)

    buffer = '\n'.join(result)
    if options.resume:

        buffer += '\n\n+{0}+\n'.format('-' * 77)
        buffer += '| Term {0:24} | Appears in lines {1:26} |\n'.format(
            ' ', ' ')
        buffer += '+{0}+\n'.format('-' * 77)
        for k, v in resume.iteritems():
            buffer += '| {term:30}| {data:43} |\n'.format(
                term=k[:30], data=str(v), num=len(v)
            )
        buffer += '+{0}+\n'.format('-' * 77)
        buffer += '| Total {num} terms {void:60} |\n'.format(
            num=len(resume), void=''
        )
        buffer += '+{0}+\n'.format('-' * 77)

    print '\n{0}'.format(buffer)
    if dest is not None:
        with open(dest, 'w') as fd:
            fd.write(buffer)

            print '\n\nFile {file} has been written to the drive\n'.format(
                file=dest
            )


if __name__ == '__main__':
    main()
